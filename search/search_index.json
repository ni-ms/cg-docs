{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Story and Screenplay With the requirements of a small, self-contained story, all the group members got together to brainstorm a plot that could both stand on its own with a short runtime while also being realizable with the team\u2019s technical abilities. We ended up choosing a simple comedy short idea which was refined over the course of 3 days through full team meets. The story follows a ninja standing on the platform in Library lawns. He encounters various basic graphic primitives that he has to evade and battle. Eventually they sneak up on him and our hero falls to the ground, defeated. The venue changes to our Computer Graphics classroom where we find out our brave protagonist was in fact a student who fell asleep in class, with the \u2018primitive\u2019 that got the best of him in reality being a chalk piece that was flung at him by the disgruntled professor. The work on the screenplay started soon after, where each scene and shot were described in detail. The group\u2019s artists quickly whipped up the rough sketches for the locations that the short was going to take place in which then served as a template for the coders in the team to start creating the backgrounds in OpenGL.","title":"Story and Screenplay"},{"location":"#story-and-screenplay","text":"With the requirements of a small, self-contained story, all the group members got together to brainstorm a plot that could both stand on its own with a short runtime while also being realizable with the team\u2019s technical abilities. We ended up choosing a simple comedy short idea which was refined over the course of 3 days through full team meets. The story follows a ninja standing on the platform in Library lawns. He encounters various basic graphic primitives that he has to evade and battle. Eventually they sneak up on him and our hero falls to the ground, defeated. The venue changes to our Computer Graphics classroom where we find out our brave protagonist was in fact a student who fell asleep in class, with the \u2018primitive\u2019 that got the best of him in reality being a chalk piece that was flung at him by the disgruntled professor. The work on the screenplay started soon after, where each scene and shot were described in detail. The group\u2019s artists quickly whipped up the rough sketches for the locations that the short was going to take place in which then served as a template for the coders in the team to start creating the backgrounds in OpenGL.","title":"Story and Screenplay "},{"location":"OpenGL/","text":"Commands All the code used to create the OpenGL drawings used the FreeGLUT library, an open-source alternative to the OpenGL Utility Toolkit library. As such, all of them required a couple common instantiations:- glutInit(&argc, argv); This function initializes the toolkit and the arguments are the standard ones for passing command-line information. glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); This function specifies how the display should be initialized. GLUT_SINGLE specifies that a single display buffer should be allocated and the colors are specified using desired amounts of red, green and blue. glutInitWindowSize(640,480); This function specifies the screen window should be 640 x 480 pixels in dimensions (initially). glutInitWindowPosition(100,150); This function specifies the window\u2019s upper left corner should be positioned on the screen 100 pixels from the left edge and 150 pixels from the top edge. glutCreateWindow(\u201dTesting\u201d); This function opens and displays the screen window with a title of \u201cTesting\u201d. Compiler Flags g++ -Wall -DUSEGLEW -o test testfile.cpp -lfreeglut -lglew32 -lglu32 -lopengl32 -lm Miscellaneous commands glColor3f(red, green, blue); Specifies the current drawing color The background is set using glClearColor(red, green, blue, alpha);, where alpha specifies the transparency. The above function only sets a state variable, but for the background to actually clear to the set value, glClear(GL_COLOR_BUFFER_BIT); has to be used myInit() is a user defined function that was used to set up the coordinate system. Example of a complete OpenGL Program #include <windows.h> #include <GL/Gl.h> #include <GL/glu.h> #include <GL/glut.h> //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< myInit >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> void myInit(void) { glClearColor(1.0, 1.0, 1.0, 0.0); glColor3f(0.0f, 0.0f, 0.0f); glPointSize(4.0); // sets the point size to 4 x 4 pixels glMatrixMode(GL_PROJECTION); // sets up the appropriate matrices glLoadIdentity(); gluOrtho2D(0.0, 640.0, 0.0, 480.0); } //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< myDisplay >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> void myDisplay(void) { glClear(GL_COLOR_BUFFER_BIT); // clears the screen to the previously set color glBegin(GL_POINTS); glVertex2i(289, 190); glVertex2i(320, 128); glVertex2i(239, 67); glVertex2i(194, 101); glVertex2i(129, 83); glVertex2i(75, 73); glVertex2i(74, 74); glVertex2i(20, 10); glEnd(); glFlush(); // send all the output to display } //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< main >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> int main(int argc, char** argv) { glutInit(&argc, argv); int mode = GLUT_RGB|GLUT_SINGLE; glutInitDisplayMode(mode); glutInitWindowSize(640,480); glutInitWindowPosition(100,150); glutCreateWindow(\"Test Window\"); myInit(); glutDisplayFunc(myDisplay); glutMainLoop(); } Output","title":"OpenGL Instantiations"},{"location":"OpenGL/#commands","text":"All the code used to create the OpenGL drawings used the FreeGLUT library, an open-source alternative to the OpenGL Utility Toolkit library. As such, all of them required a couple common instantiations:- glutInit(&argc, argv); This function initializes the toolkit and the arguments are the standard ones for passing command-line information. glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); This function specifies how the display should be initialized. GLUT_SINGLE specifies that a single display buffer should be allocated and the colors are specified using desired amounts of red, green and blue. glutInitWindowSize(640,480); This function specifies the screen window should be 640 x 480 pixels in dimensions (initially). glutInitWindowPosition(100,150); This function specifies the window\u2019s upper left corner should be positioned on the screen 100 pixels from the left edge and 150 pixels from the top edge. glutCreateWindow(\u201dTesting\u201d); This function opens and displays the screen window with a title of \u201cTesting\u201d.","title":"Commands"},{"location":"OpenGL/#compiler-flags","text":"g++ -Wall -DUSEGLEW -o test testfile.cpp -lfreeglut -lglew32 -lglu32 -lopengl32 -lm","title":"Compiler Flags"},{"location":"OpenGL/#miscellaneous-commands","text":"glColor3f(red, green, blue); Specifies the current drawing color The background is set using glClearColor(red, green, blue, alpha);, where alpha specifies the transparency. The above function only sets a state variable, but for the background to actually clear to the set value, glClear(GL_COLOR_BUFFER_BIT); has to be used myInit() is a user defined function that was used to set up the coordinate system.","title":"Miscellaneous commands"},{"location":"OpenGL/#example-of-a-complete-opengl-program","text":"#include <windows.h> #include <GL/Gl.h> #include <GL/glu.h> #include <GL/glut.h> //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< myInit >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> void myInit(void) { glClearColor(1.0, 1.0, 1.0, 0.0); glColor3f(0.0f, 0.0f, 0.0f); glPointSize(4.0); // sets the point size to 4 x 4 pixels glMatrixMode(GL_PROJECTION); // sets up the appropriate matrices glLoadIdentity(); gluOrtho2D(0.0, 640.0, 0.0, 480.0); } //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< myDisplay >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> void myDisplay(void) { glClear(GL_COLOR_BUFFER_BIT); // clears the screen to the previously set color glBegin(GL_POINTS); glVertex2i(289, 190); glVertex2i(320, 128); glVertex2i(239, 67); glVertex2i(194, 101); glVertex2i(129, 83); glVertex2i(75, 73); glVertex2i(74, 74); glVertex2i(20, 10); glEnd(); glFlush(); // send all the output to display } //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< main >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> int main(int argc, char** argv) { glutInit(&argc, argv); int mode = GLUT_RGB|GLUT_SINGLE; glutInitDisplayMode(mode); glutInitWindowSize(640,480); glutInitWindowPosition(100,150); glutCreateWindow(\"Test Window\"); myInit(); glutDisplayFunc(myDisplay); glutMainLoop(); }","title":"Example of a complete OpenGL Program"},{"location":"OpenGL/#output","text":"","title":"Output "},{"location":"Scenes/","text":"Making the scenes Drawing the key backgrounds of the locations we wanted the story to occur in required us to start with the rough sketches of the final drawings made on paper :- Block-C and platform Auditorium and library lawns After which we redrew these backgrounds on a grid to get the approximate coordinates of all the points and necessary parameters :- Using the coordinates from the graph drawing and all the routines developed, the scenes were painstakingly put together polygon by polygon :-","title":"Methodology of Drawing"},{"location":"Scenes/#making-the-scenes","text":"Drawing the key backgrounds of the locations we wanted the story to occur in required us to start with the rough sketches of the final drawings made on paper :- Block-C and platform Auditorium and library lawns After which we redrew these backgrounds on a grid to get the approximate coordinates of all the points and necessary parameters :- Using the coordinates from the graph drawing and all the routines developed, the scenes were painstakingly put together polygon by polygon :-","title":"Making the scenes"},{"location":"Together/","text":"Putting it all together The final panels were then edited and put together using photoshop. Hand drawn figures were overlaid on top of the OpenGL scenes. The sound effects were taken from various open source websites. They were then edited with audacity, a free audio editing tool. Finally Adobe aftereffects was used to convert the collection of panels into a video complete with narration and sound effects.","title":"Putting the panel together"},{"location":"Together/#putting-it-all-together","text":"The final panels were then edited and put together using photoshop. Hand drawn figures were overlaid on top of the OpenGL scenes. The sound effects were taken from various open source websites. They were then edited with audacity, a free audio editing tool. Finally Adobe aftereffects was used to convert the collection of panels into a video complete with narration and sound effects.","title":"Putting it all together"},{"location":"code/","text":"","title":"Code"},{"location":"credits/","text":"Credits Contributors Abhinav - Illustration, AfterEffects Kshitij Singh Bhadoria - Doxygen Nikhil - Documentation, Webpage Development Piyush - OpenGL, Doxygen, Sound Effects Rishi - OpenGL, Documentation, Narration Riya - Illustration Special Thanks to Prof. Tathagata Ray - Voice acting, Guidance","title":"Credits"},{"location":"credits/#credits","text":"","title":"Credits"},{"location":"credits/#contributors","text":"Abhinav - Illustration, AfterEffects Kshitij Singh Bhadoria - Doxygen Nikhil - Documentation, Webpage Development Piyush - OpenGL, Doxygen, Sound Effects Rishi - OpenGL, Documentation, Narration Riya - Illustration","title":"Contributors"},{"location":"credits/#special-thanks-to","text":"Prof. Tathagata Ray - Voice acting, Guidance","title":"Special Thanks to"},{"location":"Algorithms/Circle/","text":"Circle drawing algorithm Description The circle drawing algorithm was taken from the one taught in class. The circle was divided into 8 identical sections and the points were computed for one section, after which the 8-way symmetry was used to duplicate the points and formulate the complete circle. The final main routine takes in the radius and the center of the circle as integer arguments to compute the points in one of the octants. Another routine \u2018drawCircle\u2019 was used to then duplicate the aforementioned points. Implementation void drawCircle( GLint x, GLint y, GLint x0, GLint y0) { glBegin( GL_POINTS ); glVertex2i( x + x0, y + y0); glVertex2i( x + x0, -y + y0); glVertex2i( -x + x0, y + y0); glVertex2i( -x + x0, -y + y0); glVertex2i( y + x0, x + y0); glVertex2i( y + x0, -x + y0); glVertex2i( -y + x0, x + y0); glVertex2i( -y + x0, -x + y0); glEnd(); } void circleplot(int x0, int y0, int r) { int x = 0; int y = r; int d = 1 - r; int deltaE = 3; int deltaSE = -2*r + 5; drawCircle(x, y, x0, y0); while (y>x){ if(d<0){ d += deltaE; deltaE += 2; deltaSE += 2; } else{ d += deltaSE; deltaE += 2; deltaSE += 4; y--; } x++; drawCircle(x , y , x0, y0); } } NOTE: One of the scenes required us to draw half circles, which was achieved by simply modifying the \u2018drawCircle\u2019 routine to just output the upper half circle points.","title":"Circle Drawing"},{"location":"Algorithms/Circle/#circle-drawing-algorithm","text":"","title":"Circle drawing algorithm"},{"location":"Algorithms/Circle/#description","text":"The circle drawing algorithm was taken from the one taught in class. The circle was divided into 8 identical sections and the points were computed for one section, after which the 8-way symmetry was used to duplicate the points and formulate the complete circle. The final main routine takes in the radius and the center of the circle as integer arguments to compute the points in one of the octants. Another routine \u2018drawCircle\u2019 was used to then duplicate the aforementioned points.","title":"Description"},{"location":"Algorithms/Circle/#implementation","text":"void drawCircle( GLint x, GLint y, GLint x0, GLint y0) { glBegin( GL_POINTS ); glVertex2i( x + x0, y + y0); glVertex2i( x + x0, -y + y0); glVertex2i( -x + x0, y + y0); glVertex2i( -x + x0, -y + y0); glVertex2i( y + x0, x + y0); glVertex2i( y + x0, -x + y0); glVertex2i( -y + x0, x + y0); glVertex2i( -y + x0, -x + y0); glEnd(); } void circleplot(int x0, int y0, int r) { int x = 0; int y = r; int d = 1 - r; int deltaE = 3; int deltaSE = -2*r + 5; drawCircle(x, y, x0, y0); while (y>x){ if(d<0){ d += deltaE; deltaE += 2; deltaSE += 2; } else{ d += deltaSE; deltaE += 2; deltaSE += 4; y--; } x++; drawCircle(x , y , x0, y0); } } NOTE: One of the scenes required us to draw half circles, which was achieved by simply modifying the \u2018drawCircle\u2019 routine to just output the upper half circle points.","title":"Implementation"},{"location":"Algorithms/Ellipse/","text":"Ellipse drawing algorithm Description The Midpoint Drawing algorithm was again used to draw ellipses. Since they have a 4-way symmetry, only one of the quadrants were required to be computed, which were then further divided into 2 regions, one where |slope| was less than 1 and the other where it was greater. All the ellipses that we required for the scene only had their upper halves and as such, the points were only duplicated wrt. the y-axis. The final routine takes in a and b, the lengths of the ellipse\u2019s axes and its center as integer arguments. Implementation void drawEllipse(int a, int b, GLint valx, GLint valy){ double d2; int x = 0; int y = b; double d1 = (b*b) - (a*a*b) + (0.25*a*a); //plot point glVertex2i(x + valx, y + valy); while ((a*a)*(y-0.5) > (b*b)*(x+1)){ //region 1 if(d1< 0) //select e d1 += b*b*(2*x + 3); else{ d1 += b*b*(2*x + 3) + a*a*(-2*y + 2); y--; } x++; glVertex2i(x + valx,y + valy); glVertex2i(-x + valx,y + valy); } d2 = ((b*b)*(x+0.5)*(x+0.5)) + (a*a*(y-1)*(y-1)) - (a*a*b*b); while(y > 0){ //region 2 if(d2 < 0){ d2 += (b*b*(2*x + 2)) + ((a*a) * (-2*y + 3)); x++; } else d2 += ((a*a)* (-2*y + 3)); y--; glVertex2i(x + valx,y + valy); glVertex2i(-x + valx,y + valy); } }","title":"Ellipse Drawing"},{"location":"Algorithms/Ellipse/#ellipse-drawing-algorithm","text":"","title":"Ellipse drawing algorithm"},{"location":"Algorithms/Ellipse/#description","text":"The Midpoint Drawing algorithm was again used to draw ellipses. Since they have a 4-way symmetry, only one of the quadrants were required to be computed, which were then further divided into 2 regions, one where |slope| was less than 1 and the other where it was greater. All the ellipses that we required for the scene only had their upper halves and as such, the points were only duplicated wrt. the y-axis. The final routine takes in a and b, the lengths of the ellipse\u2019s axes and its center as integer arguments.","title":"Description"},{"location":"Algorithms/Ellipse/#implementation","text":"void drawEllipse(int a, int b, GLint valx, GLint valy){ double d2; int x = 0; int y = b; double d1 = (b*b) - (a*a*b) + (0.25*a*a); //plot point glVertex2i(x + valx, y + valy); while ((a*a)*(y-0.5) > (b*b)*(x+1)){ //region 1 if(d1< 0) //select e d1 += b*b*(2*x + 3); else{ d1 += b*b*(2*x + 3) + a*a*(-2*y + 2); y--; } x++; glVertex2i(x + valx,y + valy); glVertex2i(-x + valx,y + valy); } d2 = ((b*b)*(x+0.5)*(x+0.5)) + (a*a*(y-1)*(y-1)) - (a*a*b*b); while(y > 0){ //region 2 if(d2 < 0){ d2 += (b*b*(2*x + 2)) + ((a*a) * (-2*y + 3)); x++; } else d2 += ((a*a)* (-2*y + 3)); y--; glVertex2i(x + valx,y + valy); glVertex2i(-x + valx,y + valy); } }","title":"Implementation"},{"location":"Algorithms/Polygon/","text":"Line drawing and Polygon Drawing Algorithm Description For drawing a line with any slope, we subdivided our drawing routine into four cases: m > 0 and dy < dx m > 0 and dy > dx m < 0 and dy < dx m < 0 and dy > dx (dy = y1 - y0, dx = x1 - x0) We used Bresenham\u2019s Line Algorithm in each of these subcategories. Further, we made sure the line is always being drawn towards the positive x-direction only so that there\u2019s only one way in which a given line can be drawn. If this wasn\u2019t implemented, then a line can be drawn from either P0 to P1, or P1 to P0; in such a scenario, there can be differences in pixels when the line passes through the midpoint. Hence having only one direction of drawing a line, removes this inconsistency in line drawing. To convince ourselves that this was the best way to draw a line between any given two points, we compared our line with the default line drawing routine of OpenGL using glBegin(GL_LINES) method. Unfortunately, we found out that the two algorithms don\u2019t match everywhere. In the picture shown, the black lines of the polygon were drawn using our implementation of Bresenham, while the red lines of the polygon were drawn using the default routine of OpenGL. The red lines should completely supersede the black lines and the black lines shouldn\u2019t be visible, but as you can see from the picture that this is not the case here. The points where the black lines are visible are the points where our algorithm and OpenGL\u2019s algorithm differ. After a few hours of scrutiny, we decided we would see for ourselves if our Bresenham\u2019s algorithm is working correctly or not. We opened up Desmos and manually checked against the points being drawn if they were correct or not. And all of them turned out to be indeed correct. This was peculiar now. Searching on the web didn\u2019t give us any concise answer to this issue, and we just concluded that OpenGL doesn\u2019t use Bresenham to plot lines. Implementation void drawDot( GLint x, GLint y) { glBegin( GL_POINTS ); glVertex2i( x, y ); glEnd(); } void swap(int &a, int &b) { // Just swaps variables. a = a^b; b = a^b; a = a^b; } void lineplot(int x0, int y0, int x1, int y1) { int dy = y1 - y0; // = a int dx = x1 - x0; // = -b // This is so that the line is always drawn towards positive x direction. This helps remove the minor issue of the line from P1 to P0 and the line from P0 to P1 not being rendered exactly the same. if(dx < 0) { swap(x0, x1); swap(y0, y1); dy = y1 - y0; dx = x1 - x0; } /* Dividing render routine into 4 subcategories: 1) when m > 0 and dy < dx 2) when m > 0 and dy > dx 3) when m < 0 and dy < dx 4) when m < 0 and dy > dx */ if(dy >= 0 && abs(dy) <= dx) { int d = 2*dy - dx; int incrE = 2*dy; int incrNE = 2*(dy - dx); int x = x0, y = y0; drawDot(x,y); while (x < x1){ if (d <= 0){ // choose E d += incrE; } else{ // choose NE d += incrNE; y++; } x++; drawDot(x,y); } } else if(dy >= 0 && abs(dy) > dx) { int d = dy - 2*dx; int incrN = -2*dx; int incrNE = 2*(dy - dx); int x = x0, y = y0; drawDot(x, y); while(y < y1) { if(d <= 0) { // choose NE d += incrNE; x++; } else { // choose N d += incrN; } y++; drawDot(x, y); } } else if(dy < 0 && abs(dy) <= dx) { int d = 2*dy + dx; int incrE = 2*dy; int incrSE = 2*(dy + dx); int x = x0, y = y0; drawDot(x,y); while (x < x1){ if (d <= 0){ // choose SE d += incrSE; y--; } else{ // choose E d += incrE; } x++; drawDot(x,y); } } else if(dy < 0 && abs(dy) > dx) { int d = dy + 2*dx; int incrS = 2*dx; int incrSE = 2*(dy + dx); int x = x0, y = y0; drawDot(x, y); while(y > y1) { if(d <= 0) { // choose S d += incrS; } else { // choose SE d += incrSE; x++; } y--; drawDot(x, y); } } } Note: Additionally, a simple loop was later created to allow for drawing polygons using the lineplot routine as the base.","title":"Line and Polygon Drawing"},{"location":"Algorithms/Polygon/#line-drawing-and-polygon-drawing-algorithm","text":"","title":"Line drawing and Polygon Drawing Algorithm"},{"location":"Algorithms/Polygon/#description","text":"For drawing a line with any slope, we subdivided our drawing routine into four cases: m > 0 and dy < dx m > 0 and dy > dx m < 0 and dy < dx m < 0 and dy > dx (dy = y1 - y0, dx = x1 - x0) We used Bresenham\u2019s Line Algorithm in each of these subcategories. Further, we made sure the line is always being drawn towards the positive x-direction only so that there\u2019s only one way in which a given line can be drawn. If this wasn\u2019t implemented, then a line can be drawn from either P0 to P1, or P1 to P0; in such a scenario, there can be differences in pixels when the line passes through the midpoint. Hence having only one direction of drawing a line, removes this inconsistency in line drawing. To convince ourselves that this was the best way to draw a line between any given two points, we compared our line with the default line drawing routine of OpenGL using glBegin(GL_LINES) method. Unfortunately, we found out that the two algorithms don\u2019t match everywhere. In the picture shown, the black lines of the polygon were drawn using our implementation of Bresenham, while the red lines of the polygon were drawn using the default routine of OpenGL. The red lines should completely supersede the black lines and the black lines shouldn\u2019t be visible, but as you can see from the picture that this is not the case here. The points where the black lines are visible are the points where our algorithm and OpenGL\u2019s algorithm differ. After a few hours of scrutiny, we decided we would see for ourselves if our Bresenham\u2019s algorithm is working correctly or not. We opened up Desmos and manually checked against the points being drawn if they were correct or not. And all of them turned out to be indeed correct. This was peculiar now. Searching on the web didn\u2019t give us any concise answer to this issue, and we just concluded that OpenGL doesn\u2019t use Bresenham to plot lines.","title":"Description"},{"location":"Algorithms/Polygon/#implementation","text":"void drawDot( GLint x, GLint y) { glBegin( GL_POINTS ); glVertex2i( x, y ); glEnd(); } void swap(int &a, int &b) { // Just swaps variables. a = a^b; b = a^b; a = a^b; } void lineplot(int x0, int y0, int x1, int y1) { int dy = y1 - y0; // = a int dx = x1 - x0; // = -b // This is so that the line is always drawn towards positive x direction. This helps remove the minor issue of the line from P1 to P0 and the line from P0 to P1 not being rendered exactly the same. if(dx < 0) { swap(x0, x1); swap(y0, y1); dy = y1 - y0; dx = x1 - x0; } /* Dividing render routine into 4 subcategories: 1) when m > 0 and dy < dx 2) when m > 0 and dy > dx 3) when m < 0 and dy < dx 4) when m < 0 and dy > dx */ if(dy >= 0 && abs(dy) <= dx) { int d = 2*dy - dx; int incrE = 2*dy; int incrNE = 2*(dy - dx); int x = x0, y = y0; drawDot(x,y); while (x < x1){ if (d <= 0){ // choose E d += incrE; } else{ // choose NE d += incrNE; y++; } x++; drawDot(x,y); } } else if(dy >= 0 && abs(dy) > dx) { int d = dy - 2*dx; int incrN = -2*dx; int incrNE = 2*(dy - dx); int x = x0, y = y0; drawDot(x, y); while(y < y1) { if(d <= 0) { // choose NE d += incrNE; x++; } else { // choose N d += incrN; } y++; drawDot(x, y); } } else if(dy < 0 && abs(dy) <= dx) { int d = 2*dy + dx; int incrE = 2*dy; int incrSE = 2*(dy + dx); int x = x0, y = y0; drawDot(x,y); while (x < x1){ if (d <= 0){ // choose SE d += incrSE; y--; } else{ // choose E d += incrE; } x++; drawDot(x,y); } } else if(dy < 0 && abs(dy) > dx) { int d = dy + 2*dx; int incrS = 2*dx; int incrSE = 2*(dy + dx); int x = x0, y = y0; drawDot(x, y); while(y > y1) { if(d <= 0) { // choose S d += incrS; } else { // choose SE d += incrSE; x++; } y--; drawDot(x, y); } } } Note: Additionally, a simple loop was later created to allow for drawing polygons using the lineplot routine as the base.","title":"Implementation"}]}